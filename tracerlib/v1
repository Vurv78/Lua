--@name libs.tracer
--@author Vurv
--@shared
if SERVER then
    // to do

else
    local DoDebug
    libs_tracer = { data = { rts = {} } }
    libs_tracer.setDebug = function(Mode)
        // Mode 0 = off, 1 = functions being called , 2 = all/intense
        DoDebug = Mode or 0
    end
    libs_tracer.createTrace = function(Index,Res,Tracing,Done)
        assert(type(Tracing)=="function","Needs a tracing function.")
        assert(type(Done)=="function","Needs a finish trace function.")
        local rttab = libs_tracer.data.rts
        local def_entity = chip()
        Index = type(Index)=="Number" and Index or (#rttab+1)
        local traceobj = {
            res = type(Res)=="Vector" and Res or Vector(512,512),
            index = Index,
            ent = def_entity,
            ang = def_entity:getAngles(),
            pos = def_entity:getPos(),
            tracefunc = Tracing,
            donefunc = Done,
            tracing = false,
            finished = false,
            showing = false,
            x = 0,
            y = 0,
        }
        render.createRenderTarget("libs.tracer_"..Index)
        rttab[Index] = traceobj
        return true
    end
    
    libs_tracer.setCamera = function(Ind,Ent)
        // Sets an indexed raytrace to a 'camera' object. Returns true/false whether this went through successfully.
        if not Ind then return false end
        local loctab = libs_tracer.data.rts[Ind]
        if loctab==nil then return false end
        if not Ent:isValid() then return false end
        loctab.ent = Ent
        loctab.ang = Ent:getAngles()
        loctab.pos = Ent:getPos()
        return true
    end
    libs_tracer.toggleTrace = function(Ind,Bool)
        if not Ind then return false end
        libs_tracer.data.rts[Ind].tracing = (Bool or false)
        return true
    end
    
    libs_tracer.showTrace = function(Ind,Bool)
        if not Ind then return false end
        libs_tracer.data.rts[Ind].showing = (Bool or false)
    end
    
    hook.add("renderoffscreen","libs.tracer_renderoffscreen",function()
        local Traces = libs_tracer.data.rts
        local Executions = 0
        for K,TraceData in pairs(Traces) do
            Executions = 0
            while math.max(quotaAverage(), quotaUsed()) < quotaMax()*0.05 and Executions < 100 do
                if TraceData.finished then continue end
                if not TraceData.tracing then continue end
                local Res = TraceData.res
                local Scale = (1024/Res)
                render.selectRenderTarget("libs.tracer_"..K)
                    local X = TraceData.x
                    local Y = TraceData.y
                    if X >= (Res.x-1) then
                        if Y >= Res.y-1 then TraceData.finished = true TraceData.donefunc() end
                        TraceData.y = (Y + 1)%Res.y
                    end
                    TraceData.x = (X + 1)%Res.x
                    local Pos = TraceData.pos
                    local Dir = Vector(100,-X+Res.x/2,-Y+Res.y/2 ):getRotated(TraceData.ang):getNormalized()
                    local ActualTrace = trace.trace(Pos,Pos+Dir*60000,{TraceData.ent})
                    render.setColor(dotrace(TraceData,ActualTrace))
                    render.drawRectFast(X*Scale.x,Y*Scale.y,Scale.x,Scale.y)
                render.selectRenderTarget()
                Executions = Executions + 1
            end
        end
    end)
    
    hook.add("render","libs.tracer_render",function()
        local Traces = libs_tracer.data.rts
        for K,TraceData in pairs(Traces) do
            if TraceData.showing then
                // Only show the first result, as showing multiple kinda lame..
                render.setRenderTargetTexture("libs.tracer_"..K)
                render.drawTexturedRectFast(0,0,512,512)
                break
            end
        end
    end)
    return libs_tracer
end
